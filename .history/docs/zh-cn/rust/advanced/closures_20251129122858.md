# chapter_14

闭包是可以捕获外部环境中的变量的匿名函数。它所引用的外部变量被称为自由变量(这些变量本不属于闭包函数的作用域范围)。
与普通函数类似，闭包可以执行代码逻辑、接收参数输入，并返回值。相对于普通函数有如下优势:
* 如果只需要在一个地方使用某个函数，闭包是更简便的选择。
* 闭包是一等公民，可以将闭包作为函数参数、返回值，甚至赋值给变量。
* 闭包一般定义在使用它的附近，这使得代码的可维护性更好。

闭包可以实现Fn、FnMut、FnOnce三个不同的trait,分别对应不同的行为。需要注意的是，这里Fn和定义函数指针类型使用的fn是不同的。绝大多数情况下，编译器根据上下文自动推断闭包应该实现哪个trait.
需要注意的是
1. 闭包通常不需要声明返回值类型，编译器自动上下文推导出来。
2. 闭包不是嵌套函数，因为嵌套函数无法捕获定义在它们外层函数作用域中的变量。这也是闭包和嵌套函数的区别。
3. 嵌套函数有显式的函数名，而闭包则是匿名的

## 闭包语法
```rust
|parameter_1, .., parameter_n|->return_type {
    代码块
}
```
et value = 10;
示例
```rust
fn main() {
    //计算立方体
    let cubed = |number: usize|->usize {
        number*number*number
    };

    let value = 10;
    let ret = cubed(value);
    println!("{}", ret);
}
```
以上代码可以简化为以下形式
```rust
fn main() {
    let cubed = |number| number*number*number;

    let value = 10;
    let ret = cubed(value);
    println!("{}", ret);
}
```

## 捕获变量
闭包可以捕获自由变量，被捕获的变量在闭包内部可用。最常见的情况，捕获的变量是对自由变量的借用。
```rust
fn main() {
    let value = 23;
    let cubed = || value*value*value;
    let ret = cubed();
    println!("{}", ret);
}
```
上述代码中，闭包捕获的变量是被借用的。


示例
```rust
fn main() {
    let mut values1 = (13, 20);

    // 借用开始
    let swap_values = || (values1.1, values1.0);

    let values2 = &mut values1;    
    let ret = swap_values(); //借用结束
    

    println!("{:?}", ret);
}
```
闭包对values1执行了借用，这个借用会一直持续，直到闭包被调用后。
而values2变量在那个范围内声明为可变借用，而Rust不允许在同一个变量上同时存在可变和不可变的借用，这会导致编译错误。

```rust
fn main() {
    let mut values1 = (13, 20);

    // 借用开始
    let swap_values = || (values1.1, values1.0);
    let mut ret = swap_values(); //原借用结束位置
    let values2 = &mut values1;    
    ret = swap_values(); //借用被延长后的结束位置


    println!("{:?}", ret);
}
```
这段代码中，swap_values被调用两次，这将最初的借用范围扩展到第二次调用swap_values()之后。在这个范围内尝试对该自由变量执行可变借用，将无法编译。

修改如下
```rust
fn main() {
    let mut values1 = (13, 20);

    // 借用开始
    let swap_values = || (values1.1, values1.0);
    let mut ret = swap_values(); //原借用结束位置
    
    ret = swap_values(); //借用被延长后的结束位置


    println!("{:?}", ret);
    let values2 = &mut values1;    
}
```

## 闭包作为函数参数

作为函数参数，需要使用impl关键字指定Fn trait,还必须提供函数定义。

> 闭包可能实现了Fn、FnMut、FnOnce trait，现在我们将专注于Fn trait。
```rust
fn do_closure(run: impl Fn()) {
    run();
}

fn main() {
    let display = || println!("Message");
    do_closure(display);
}
```

更复杂的例子

```rust
enum Calculation {
    Cubed,
    Quad,
}

fn get_retsult(run: impl Fn(i32) -> i32, value: i32) -> i32 {
    run(value)
}

fn main() {
    let cubed = |value: i32| value * value * value;
    let quad = |value: i32| value * value * value * value;
    let calculation = Calculation::Cubed;
    let ret = match calculation {
        Calculation::Cubed => get_retsult(cubed, 5),
        Calculation::Quad => get_retsult(quad, 5),
    };
    println!("{}", ret);
}

```

## 闭包作为返回值
与参数一样，impl关键字可用于指定一个闭包trait,比如Fn trait.

```rust

fn get_closure()->impl Fn(i32)->i32 {
  |number|number*number*number
}

fn main() {
   let cubed = get_closure();
   let ret = cubed(4);
   println!("{}", ret);
}
```

更复杂的例子
```rust
enum Calculation {
    Cubed,
    Quad,
}
fn get_closure(calculation: Calculation)->impl Fn(i32)->i32 {
    match calculation {
        Calculation::Cubed => |value: i32| value*value*value,
        Calculation::Quad => |value: i32| value*value*value*value,
    }
}

fn main() {
    let calculation = Calculation::Cubed;
    let fun = get_closure(calculation);

    let ret = fun(4);
    println!("{}",ret);
}
```

## 闭包的实现
Rust闭包在编译时会被转换为结构体，而捕获的变量会成为该结构体的字段。
闭包函数实际上是闭包结构体的一个方法，像其他方法一样，第一个参数是self。闭包结构体内没有对闭包函数的引用，因为没有必要。
闭包方法的属性(self参数的定义)，取决于编译期间编译器选择实现的是Fn、FnMut还是FnOnce。
```rust
fn main() {
    let (a, b) = (1, 2);
    let adder = |prefix: String| println!("{} {}", prefix, a+b);

    adder("Add: ".to_string());   
}
```
被转换的结构体可能的形式
```rust
struct adder {
    a: i32,
    b: i32,
}

impl Fn<(String)> for adder {
    type Output = ();
    fn call(&self, args: Arg)->Self::Output {
        //这里省略细节
    }
}
```




这三个trait之间存在层次关系。实现闭包时，优先选择Fn,其次是FnMut,最后是FnOnce。
![alt text](image-10.png)

例如，FnMut trait是Fn trait的父trait,这意味着在需要Fn trait的地方可以使用FnMut trait代替，而反过来却不行。

## Fn trait
闭包如果是不可变的，则实现了Fn trait,这意味着捕获的变量也必须是不可变的，对于Fn trait,闭包方法的self是&Self,捕获的变量则是借用语义。
```rust
fn do_closure(closure: impl Fn()) {
    closure()
}
fn main() {
    
    let hello = || println!("hello");
    do_closure(hello);
}
```
hello闭包没有捕获任何变量，意味着这个闭包是不可变的，并实现了Fn trait。

对上面代码稍作修改
```rust
fn do_closure(closure: impl Fn()) {
    closure()
}
fn main() {
    let hello_string = "hello".to_string();
    let hello = || println!("{}",hello_string);
    do_closure(hello);
}
```
现在hello闭包捕获了hello_string,捕获的变量是不可变的，因此编译器自动为不可变上下文实现了Fn trait

```rust
fn do_closure(closure: &mut impl FnMut()) {
    closure()
}

fn main() {
    let mut hello_string = "hello".to_string();
    let mut hello = || {hello_string.push_str("world"); println!("{}",hello_string)};

    do_closure(&mut hello);
}
```
上述代码中，hello_string是可变的，变量仍然可以作为自由变量在hello闭包中被捕获。闭包现在有一个可变的状态，并且自动实现FnMut。
do_closure函数参数更改为FnMut来确认该闭包实现了FnMut.

一个没有捕获任何外部变量的闭包，实际上就等同于一个标准函数。因此，标准函数和无捕获上下文的闭包是可以相互转换的。这就是为什么Fn trait也适用于标准函数。
```rust
fn do_closure(closure: impl Fn()) {
    closure()
}
fn main() {
    fn hello() {
        println!("hello")
    }
    do_closure(hello);
}
```

## FnMut trait
FnMut trait适用于那些捕获了可变上下文的闭包，对于实现了FnMut trait的闭包，其方法中的self参数类型是&mut Self。
```rust
fn do_closure(mut closure: impl FnMut()) {
    closure()
}

fn main() {
    let mut value = 0;
    let incremant = || value=value+1;
    do_closure(incremant);
    println!("{}",value);
}
```

## FnOnce trait
FnOnce trait适用于那些只能被执行一次的闭包。实现了FnOnce trait的闭包就只能被执行一次。对于FnOnce trait,闭包方法的self参数类型是Self,即闭包获取了被捕获变量的所有权。这激素为什么FnOnce闭包只能被调用一次。
```rust
fn do_closure(closure: impl FnOnce()->String) {
    closure();
    closure(); //报错
}

fn main() {
    let hello_string = "hello".to_string();

    let hello = || hello_string;

    do_closure(hello);
}
```
在下面闭包中，捕获的字符串被丢弃，由于同一个字符串只能被丢弃一次，编译器可以识别这一点，并为闭包实现FnOnce trait。

```rust
fn do_closure(closure: impl FnOnce()) {
    closure();
}

fn main() {
    let hello_string = "hello".to_string();
    let hello = || drop(hello_string);
    do_closure(hello);
}
```
由于FnOnce是FnMut和Fn的subtrait,因此任何实现了Fn/FnMut的闭包都可以作为FnOnce实例使用。
```rust
fn do_closure(closure: impl FnOnce()) {
    closure();
}

fn main() {
    let hello_string = "hello".to_string();
    let hello = || println!("{}",hello_string);
    do_closure(hello);
}
```
尽管hello实现了Fn,由于绑定到closure这个FnOnce变量，因此在do_closure中只能被执行一次。
```rust
fn do_closure(closure: impl FnOnce()) {
    closure();
    closure(); //编译错误
}

fn main() {
    let hello_string = "hello".to_string();
    let hello = || println!("{}",hello_string);
    do_closure(hello);
}
```

## move关键字
每个函数在运行时都会在栈上分配一个私有的内存区域(栈帧),用于存储函数的局部变量和寄存器状态等上下文信息。
闭包可以从外部函数的栈帧中捕获变量值作为自由变量引用。由于这一机制，闭包并不完全拥有它们所使用的环境。这可能会导致一些问题。
```rust
fn get_closure()->impl Fn()->i32 {
    let a = 10;
    let b = 20;
    || a+b // 编译错误
}

fn main() {
    let fun = get_closure();
    fun();
}
```
get_closure函数返回一个依赖于捕获值a,b的闭包，这就产生了对外部函数环境的依赖。但是当闭包返回时，外部函数的栈帧会被销毁。

解决办法是使用move关键字，使用move关键字的闭包会获取去捕获环境的完整所有权，不再依赖于外部函数的栈帧。被捕获的变量值会被转移到闭包的环境中，根据值的类型决定采用移动或复制语义。
```rust
fn get_closure() -> impl Fn() -> i32 {
    let a = 10;
    let b = 20;
    move || a + b // 编译错误
}

fn main() {
    let fun = get_closure();
    let ret = fun();
    println!("{}", ret);
}
```

## impl 关键字
trait本身是不确定大小的，因此我们无法直接创建trait的实例。要使用trait,可以通过静态分派和动态分派的方式管理具体实现了该trait的类型实例。
impl关键字就是为闭包显式指定实现的trait。impl关键字并非适用于所有场景，如变量绑定的情况。
例如
```rust
type closure_tuple = (impl Fn(), impl Fn(),)
```
或是
```rust
use std::collections::HashMap;

fn main() {
    let map = HashMap<i32, impl Fn()>::new();
    map.insert(0,|| println!("hello"));
}
```
这种情况下，我们可以考虑使用静态分派和动态分派

静态分派
```rust
struct AStruct<T>
where T: Fn() {
    hello: T,
}
fn main() {
    let astruct = AStruct { hello: || println!("hello")};
    (astruct.hello)()
}
```

动态分派
```rust
fn main() {
    let hello: &dyn Fn() = &|| println!("hello");
    hello();
}
```

```rust
use std::collections::HashMap;

type Row = (char, i32, i32, i32);
type OperationType<'a> = &'a dyn Fn(Row)->i32;


fn main() {
    let mut matrix = vec![
        ('a', 4, 5, 0),
        ('m', 2, 6, 0),
        ('d', 9 ,3, 0),
        ('s', 5, 6, 0),
    ];
    let mut operation: HashMap<char, OperationType>;

    operation = HashMap::new();
    operation.insert('a', &|row| row.1+row.2);
    operation.insert('m', &|row| row.1*row.2);
    operation.insert('d', &|row| row.1/row.2);
    operation.insert('s', &|row| row.1-row.2);

    for each_row in matrix.iter_mut() {
        each_row.3 = operation.get(&each_row.0).unwrap()(*each_row);
    }
    println!("{:?}",matrix)
}
```