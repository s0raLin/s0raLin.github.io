# chapter_9

生命周期描述的是一个值在程序中的存活范围。不同生命周期的交叉关系，可能会导致悬垂引用的出现。

生命周期的命名方式是('生命周期名称)。不同通常以小写字母命名,如'a、'b、’c。
```rust
fn main() {
    let ref1;
    {
        let num1 = 2;
        ref1 = &num1;
    }
    println!("{}", ref1);
}
```

在'num1的生命周期结束时，num1就被释放了。此时ref1就变成了一个悬垂引用，借用检查器检测到了这个问题，因此报错。
![alt text](zh-cn/rust/images/dangling_reference_example.png)

## 函数与生命周期
函数也可以产生不安全的内存访问，特别是引用作为参数并返回值的函数。
对于一个包含引用的函数定义来说，我们需要考虑三种不同类型的生命周期:
* **输入生命周期** 即类型参数是引用类型的情况，一个函数可以有多个输入生命周期

* **输出生命周期** 指返回值的生命周期，输出生命周期通常会从函数的输入生命周期中选取(虽然可以返回静态值的引用，但这种情况不常见)
![alt text](output_lifetime.png)
* **目标生命周期** 指的是绑定到函数返回值引用的生命周期
![alt text](target_lifetime.png)
只要目标生命周期的范围超出输出生命周期，就有可能导致悬垂引用的问题。
在前面这个例子中目标生命周期('b)完全包含在输出生命周期('a)中，因此result变量始终是有效的，编译器成功编译。

## 生命周期省略
在遵循一定原则的情况下，编译器可以自动推导生命周期参数。
省略规则如下:
* 每个被省略的输入生命周期会被分配为一个独立的生命周期参数
* 当存在单一输入生命周期时，它会被省略，并且应用到输出引用
* 对于一个方法，如果self是一个引用，则self的生命周期会省略，并且会应用到输出引用

## 复杂的生命周期
函数接受多个引用类型参数，每个引用可能具有不同或相同的生命周期。这就意味着有多个候选的输出生命周期，这会给借用检查器带来歧义。即哪个输入生命周期应该分配给引用类型的返回值作为输出生命周期?为此，编译器不会猜测哪个是正确的输出生命周期，而是需要开发者显式标注生命周期来向编译器表达意图。

## 共享生命周期
你可以在多个参数之间共享输入生命周期。当你共享一个生命周期时，该生命周期的范围就是两个借用值生命周期的交集。

## 静态生命周期
'static表示的一个静态的生命周期，贯穿整个应用程序。
在Rust中，字符串字面量具有静态生命周期。字符串字面量是&str类型的值，他们总是静态的。

## 结构体与生命周期
结构体中的生命周期和其他地方的生命周期具有相同的作用,即防止悬垂引用。
因为结构体可以有引用的字段，如果字段引用的值没有存活足够长的时间，就会出现悬垂引用。
因此结构体中的字段必须具有与结构体本身一样长的生命周期。
* 要先在结构体名称后声明生命周期参数，然后你可以将命名的生命周期分配给引用类型的字段。
* 结构体不支持生命周期省略，一旦有引用类型的字段，必须要显式添加生命周期标注

## 方法与生命周期
为结构体实现的方法也可以接受和返回引用类型，这也是潜在的能产生悬空引用的场景。
当我们实现方法时，结构体的生命周期参数既包括在impl关键字后，也包括在结构体名称后。
```rust
struct Data<'a, 'b> {
    field1: &'a mut i32,
    field2: &'b mut i32
}   

impl<'a, 'b> Data<'a, 'b> {
    
}
```
在实现方法时，不需要重新声明结构体的生命周期，只需要简单地将生命周期应用到方法声明的引用类型上，这些和应用到字段的生命周期是相同的。当相同的生命周期应用到多个值时，编译器会采取保守计算，得到的生命周期是各个生命周期的交集。



## 子类型化生命周期
```rust
fn foo<'a: 'b, 'b>(x: &'a i32, y: &'b i32, flag: bool) -> &'b i32  
{
    if flag { x } else { y }
}

fn main() {
    let x = 1;
    {
        let y = 2;
        let z = foo(&x, &y, true);
        println!("z: {z}");
    }
}
```
'a: 'b 表示 'a的生命周期必须至少和'b一样长或更长。换句话说，'a是'b的子类型。这意味着'a可以替代'b使用


## 匿名生命周期
生命周期省略可能并不完美，有可能会出现生命周期推断错误，不适用的情况。另外生命周期标注可能过于繁琐。对于这种情况，可以使用匿名生命周期。

如果你希望在impl中省略生命周期，可以使用'_
```rust
use std::fmt::Display;



struct Data <'a>{
    ref1: &'a i32,
}

impl Display for Data<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.ref1)
    }
}
fn main() {
    let x = 5;
    let data = Data { ref1: &x };
    println!("{}", data);

}
```

## 泛型生命周期
泛型和生命周期声明的方式相同，而且它们可以结合使用。
同时声明时，生命周期参数应该先于泛型类型参数。
