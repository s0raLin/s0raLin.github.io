# chapter_4

控制台命令行程序适合很多场景，如记录事件日志、配置应用程序、接收用户输入、访问开发者工具等等。它是GUI的一种可替代方案。

Rust提供了多种与控制台进行交互的读写操作，我们从最常用的println!和print!宏开始。

## 输出(println!宏)
* println!和print!宏用于在控制台显示信息。这两个宏将格式化的字符串插入输出流(stdout)中。 区别是println!()会在格式化输出的结尾加上一个换行符`\n`。
* println!和print!宏是可变参数的，意味着可以有多个数量的参数。
* 每个宏的第一个参数是一个格式化字符串也是一个字符串字面量。格式化字符串可以包含占位符({}),宏的其余参数必须依次替换占位符所对应的位置。
* print!宏至少必须有一个参数; 而println!可以没有，仅仅表示打印换行。

---
### 格式化字符串
占位符(`{}`)保留给实现了`Display trait`的公共类型。标准库中很多原生类型(整数、浮点数)，都被视为公共类型，它们实现了`Display`这个`trait`.比如自定义的结构体(`struct`),可能并未实现`Display trait`,无法直接使用占位符(`{}`)进行格式化。

```rust
fn main() {
    let a = 10;
    let b = 20;
    println!("{} + {} = {}",a, b, a+b);
}
```
格式字符串`"{} + {} = {}"`中的占位符`"{}"`将会被后面的结果替换
![带有格式字符串和占位符的println!宏](image-1.png)

---
#### 位置参数
你也可以使用索引来指示占位符`"{}"`中的位置参数,如`"{index}"`。index是从0开始的，且是一个usize类型
```rust
fn main() {
    let a = 15;
    let b = 20;
    println!("{1}+{0}={2}",a, b,a+b);
}
```
如图
![alt text](image-2.png)

当然，你也可以混用非位置型`"{}"`和位置型`"{index}"`的占位符。但是，非位置型参数占位符`"{}"`会被优先求值
```rust
fn main() {
    let (first, second, third, tourth) = (1, 2, 3, 4);
    let result = first+second+third+tourth;
    println!("{} + {} + {3} + {} = {4}",first, second, third, tourth, result);
}
```

---
#### 变量参数
格式字符串中的占位符也可以引用变量。变量参数是一种位置参数，引用的变量必须在作用于内，并且是可见的。
```rust
fn main() {
    let (first, second, third, tourth) = (1, 2, 3, 4);
    let result = first+second+third+tourth;
    println!("{first} + {second} + {third} + {tourth} = {result}");
}
```

#### 命名参数
print!/println!宏内也可以使用命名参数。语法是name=value。这个参数可以在格式化字符串中的占位符中使用。
```rust
fn main() {
    let (first, second, third, tourth) = (1, 2, 3, 4);
    println!("{first} + {second} + {third} + {tourth} = {result}",result = first+second+third+tourth);
}
```
---
### 填充、对齐和精度
在格式化字符串中，你可以控制占位符的填充、对齐方式和数字精度。只需要在占位符后的冒号处添加格式规范即可调整对应的属性，比如`{:format}`。

你可以使用`{:width}`来设置占位符的填充和列宽。
在列中的对齐方式:
* 数字值默认是右对齐
* 字符串默认是左对齐
你可以使用以下特殊字符重写这些默认的对齐方式:
* `>`: 右对齐
* `<`: 左对齐
* `^`: 居中对齐
```rust
fn main() {
    let numbers = [("one", 10), ("two", 2000), ("three", 400)];
    println!("{:7}{:10}","Text", "Value");
    println!("{:7}{:10}","====", "====");
    for (k, v) in numbers {
        println!("{:7}{:<10}",k, v);
    }
}
```

对于浮点数，你可以在占位符`{}`中添加精度，用以控制小数点后显示的位数(并非四舍五入)。语法是padding.precision。如果没有填充宽度设置，直接使用.precision即可。需要注意的是，对于整型，precision参数会被忽略。
```rust
fn main() {
    let (float1,float2) = (3.14159,1.2);
    println!("Result: {:<10.3}{:<10.2}", float1,float2);
}
```

你可以使用$字符参数化精度或宽度。

**基本写法**
```rust
fn main() {
    let int = 43;
    let float = 3.14159;
    println!("{:5}",int);
    println!("{:.3}",float);
}
```
这里5和3是写死的。

参数化宽度/精度(用$)
```rust
fn main() {
    let width = 10;
    let precision = 5;
    let float = 3.1415926;
    println!("Result: {:width$.precision$}",float);
}
```
也可以和位置参数配合使用
```rust
fn main() {
    let float = 3.1415926;
    println!("{1:.0$}", 5,float);
}
```

如图
![alt text](image-3.png)

相应的，填充精度也可以参数化，这里不做过多演示。

---
### 进制
在`print!`/`println!`宏中，数值默认是以10进制表示的，如果你想使用其他进制，可以使用相关的字母标识符。
```rust
fn main() {
    println!("{:b}",42); //二进制
    println!("{:o}", 42); //八进制
    println!("{}", 42); //十进制(默认)
    println!("{:x}", 42); //十六进制(小写)
    println!("{:X}", 42); // 十六进制(大写)
}
```

### 开发者友好
在使用`println!`/`print!`宏时，
* 对于已经实现了`Display trait`的类型，用`{}`占位符
* 对于已经实现了`Debug trait`的类型，用`{:?}`占位符

这种区分是站在用户友好性的角度考虑，`{:?}`格式通常注重开发者视角。
* 对于标准库中的原生类型同时实现了`Display`和`Debug`这两个`trait`
* 但对于某些复杂类型，如数组和向量，只实现了`Debug`这个`trait`
```rust
fn main() {
    let vec = vec![1,2,3,4,5];
    println!("{:?}",vec);
}
```
* 而用户自定义的类型通常不会自动实现`Display`或`Debug`这两个`trait`，不过可以使用派生(`derive`)属性为自定义类型添加`Debug`的默认实现，之后在`println!`/`print!`宏调用时，可以使用`{:?}`占位符来输出
```rust
#[derive(Debug)]
struct Person<'a> {
    name: &'a str,
    age: i32,
}

fn main() {
    let person = Person {name: "张三", age: 43};
    println!("{:?}",person);
}
```
Rust还提供了`{:#?}`占位符，可以实现更优雅地输出。
```rust
#[derive(Debug)]
struct Person<'a> {
    name: &'a str,
    age: i32,
}

fn main() {
    let person = Person {name: "张三", age: 43};
    println!("{:#?}",person);
}
```

## 输出(write!宏)
* `print!`和`println!`可以将内容显示到标准输出。而`write!`更加灵活，可以将格式化的字符串输出到实现了`fmt::write trait`或`io::Write trait`的不同目标上。
* `write!`宏的参数包括目标值、格式化字符串和格式参数。
* 格式化后的字符串会被写入到目标中。因此目标需要是可变的，并且是一个借用值(`write!` 宏只需要 临时使用目标，不需要拿走所有权)
例如 `Vec`类型实现了`std::io::Write trait`,因此可以在`write!`宏中作为目标使用。
```rust
use std::io::Write;

fn main() {
    let mut vec = vec![];


    write!(&mut vec, "{}", 10);
    write!(&mut vec, "{}", 11);

    println!("{:?}",vec);
}
```
write!宏将值10和值11转为字符串。对于Vec类型来说，write!宏会将以utf-8的字符串按从前到后字节顺序插入此处为vec!类型。

在将Stdout(标准输出流，在std::io模块中，调用stdout方法获取标准输出目标)作为目标时，write!宏的行为类似于print!宏，
```rust
use std::io::Write;

fn main() {
    write!(&mut std::io::stdout(), "{}", "Hello, World!");
}
```

## Display trait
格式化字符串的{}接收实现了`Display trait`的类型的参数，用于用户友好的视图。
对于自定义的类型，可能需要为它们实现Display trait。.
```rust
pub trait Display {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>;
}
```
* 第一个参数是&self
* 第二个参数是Formatter(格式化器)，是一个输出参数，包含类型的用户友好格式渲染
该函数返回一个Result类型，以指示函数是否成功。
```rust
use std::fmt::Display;

struct Person {
    name: &'static str,
    age: i32,
}

impl Display for Person {
    fn fmt(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "名字叫{}年龄是{}", self.name, self.age)
    }
}
fn main() {
    let p = Person { name: "Alice", age: 25 };

    println!("{}", p);

}
```
write!宏将格式化后的字符串放入到formatter参数中。有了Display的实现，我们自定义的结构可以与{}占位符一起使用。


## Debug trait
{:?}占位符渲染开发者友好的格式，与{:?}一起使用的是实现了`Debug trait`的类型。
Debug trait在std::fmt模块中定义。类似于Display， trait.Debug trait包含一个fmt方法
```rust
pub trait Debug {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result<(), Error>;)
}
```
在默认情况下，自定义类型没有实现Debug trait.为了便于调试，我们可以为其实现Debug，这样我们就可以使用{:?}占位符来输出自定义结构。
```rust
use std::fmt::{Debug};

struct Person {
    name: &'static str,
    age: i32,
}


impl Debug for Person {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "人类 {{ 姓名: {}, 年龄: {} }}", self.name, self.age)
    }
}
fn main() {
    let p = Person { name: "Alice", age: 25 };

    println!("{:?}", p);

}
```

## format!宏
我们主要关注了与格式化输出有关的两个宏：print!和println!。其实还有几个相关的宏用于创建格式化字符串。
* print! 将格式化字符串发送到标准输出。
* println! 将格式化字符串追加换行符后发送到标准输出。
* eprint! 将格式化字符串发送到标准错误
* eprintln! 将格式化字符串追加换行符后发送到标准错误。
* format! 创建一个格式化后的字符串。
* lazy_format! 创建一个延迟渲染的格式化字符串。

## 控制台读写
如果需要开发一个交互式的控制台应用程序，那么必然需要通过控制台与用户进行信息交换。
Rust的标准库std::io模块提供了一些非常有用的方法。
* stdout 返回一个标准输出流的句柄，类型为Stdout
* stdin 返回一个标准输入流的句柄，类型为Stdin
* stderr 返回一个标准错误流的句柄，类型为Stderr
为了实现从控制台读取输入，Stdin实现了BufRead和Read这两个trait,提供了多个方法。
* read 将输入读入字节缓冲区
* read_line 将一行输入读入一个字符串缓冲区
* read_to_string 读取输入直到文件结束，并将文件内容存入一个字符串缓冲区。
```rust
use std::io::stdin;

fn main() {
    let mut name = String::new();
    println!("请输入你的名字");
    stdin().read_line(&mut name).unwrap_or_default();
    if name != "" {
        println!("你好 {}", name);
    } else {
        println!("请输入正确的名字");
    }
    
}
```

除了使用输出宏以外，还可以直接利用标准输出流的句柄在控制台显示信息。
1. 首先调用stdout获取标准输出流的句柄对象
2. 可以通过write_all方法来显示字节数据
```rust
use std::io::{stdout, Write};

fn main() {
    stdout().write_all(b"helloworld");

}
```

