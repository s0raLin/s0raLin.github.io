# 数据类型

## 整型
* Byte：内存中占 8 位，范围为 -2^7 ~ 2^7-1，对应 Java 中的 byte。
* Short：内存中占 16 位，范围为 -2^15 ~ 2^15-1，对应 Java 中的 short。
* Int：内存中占 32 位，范围为 -2^31 ~ 2^31-1，对应 Java 中的 int。
* Long：内存中占 64 位，范围为 -2^63 ~ 2^63-1，对应 Java 中的 long。

通过 MIN_VALUE/MAX_VALUE 获取最小/最大值。

### 注意
* 默认为 Int，当存储一个较大的整型时，默认为 Long。
* 不同类型之间通过 to 首字母大写类型名转换。

```kotlin
 fun main() {
     // Byte 类型，8 位，范围 -128 ~ 127
     val b: Byte = 100
     println("Byte b = $b")

     // Short 类型，16 位，范围 -32768 ~ 32767
     val s: Short = 30000
     println("Short s = $s")

     // Int 类型，32 位，范围 -2^31 ~ 2^31-1
     val i: Int = 2_000_000_000
     println("Int i = $i")

     // Long 类型，64 位，范围 -2^63 ~ 2^63-1
     val l: Long = 9_000_000_000_000_000_000L
     println("Long l = $l")

     // 类型转换示例：
     val iToLong: Long = i.toLong()  // Int 转 Long
     println("Int to Long: $iToLong")

     val lToInt: Int = l.toInt()     // Long 转 Int（会溢出）
     println("Long to Int (可能溢出): $lToInt")

     val iToByte: Byte = i.toByte()  // Int 转 Byte（可能溢出）
     println("Int to Byte (可能溢出): $iToByte")
 }
```
Kotlin注重null安全,
如果要接受null值,则需要使用可空类型只需要在类型后加"?"
* Byte?
* Short?
* Int?
* Long?
```kotlin
 // Int 变量不支持 null 值
 var notNull: Int = null //错误
 Int? 相当于支持 null 值的 Int 型
 var nullable : Int? = null //正确
```
Kotlin中 Int 类型的变量将会映射成 Java 的 int 基本类型，
但 Int？类型的变量则会自动映射成 Java 的 Integer 类型。
```kotlin
 var pml ：Int = 200 // pml 的类型是 Java 的 int 类型
 var pm2: Int = 200  // pm2 的类型是 Java 的 int 类型
 println(pml === pm2) // 基本类型比较，输出 true
 var obl : Int? = 200  // obl 的类型是 Java 的 Integer 类型
 var ob2 : Int? = 200  // ob2 的类型是 Java 的 Integer 类型
 println(obl === ob2) // 引用类型比较，输出 false
 //当这两个引用比较时，idea会报出警告(翻译如下)
 /*禁止对类型为“Int？”和“Int？”的参数进行恒等性*/
```
Kotlin 的整数数值有 3 种表示方式 。
1. 十进制： 默认的整数数值
2. 二进制：以 Ob 或 OB 开头的整数数值
3. 十六进制：以 Ox 或 ox 开头的整数数值，其中 10～ 15 分别以 a～f (此处的 a～f 不区分大小写)来表示。

Kotlin 不能直接表示 8 进制整数，可以通过字符串（String）的 toInt(radix) 方法转换，其中 radix 为指定的进制。

注意：为了提高数值的可读性，可以为数值加 _ 作为分隔符。

```kotlin
val price = 234_234_234 // 对应的值为 234234234
```

## 浮点型
浮点型数值可以包含小数部分，浮点型比整型的表数范围更大，可以存储比 Long 型更大
或更小的数 。 Kotlin 的浮点型有两种 。
* Float：表示 32 位的浮点型，当精度要求不高时可以使用此种类型 。
* Double(默认使用的类型)：表示 64 位的双精度浮点型，当程序要求存储很大或者高精度的浮点数时使
用这种类型 。
浮点数的表示形式
* 十进制数形式 ：这种形式就是简单的浮点数 ， 例如 5 . 12 、 512 . 0 、 0 . 5 12 等 。 浮点数必
须包含一个小数点，否则会被当成整数类型处理 。
* 科学计数形式 ：例如 5.12e2 （即 5.12 x 10^2 ） 、 5.12E2 （也是 5.12 × 10^2 ）等 。

另外,浮点数还有三个特殊值：
* 正无穷大：一个正数/0.0
* 负无穷大：一个负数/0.0
* 非数：0.0/0.0 或 0.0^(1/2)

需要注意的是:
当一个整型/0(这个0也是整型)时，会报错：division by zero(除0异常)
```kotlin
 fun main() {
  1/0
 }//Exception in thread "main" java.lang.ArithmeticException: / by zero
```
示例:
```kotlin
 fun main() {
     // 赋值为 Float 类型
     var af1 = 5.2345556f
     // 下面将看到 af1 的值已经发生了改变
     println("af1 的值为：$af1")

     // 声明 af2 是 Float 类型，但 25.2345 默认是 Double 类型，因此下行代码会报错
     // var af2: Float = 25.2345  // ❌ 编译错误：类型不匹配

     // fl 的类型被推断为 Double
     var fl = 5.12e2
     println("fl 的值为：$fl")

     var a = 0.0

     // 5.0 除以 0.0 将出现正无穷大数值
     println("5.0 / a 的值为：${5.0 / a}")

     // 所有的正无穷大数值都相等，所以输出 true
     println(5.0 / a == 50000 / 0.0)

     // -5.0 除以 0.0 将出现负无穷大数值
     println("-5.0 / a 的值为：${-5.0 / a}")

     // 所有的负无穷大数值都相等，所以输出 true
     println(-5.0 / a == -50000 / 0.0)

     // 0.0 除以 0.0 将出现 NaN（非数）
     var nan: Double = a / a
     println("a / a 的值为：$nan")

     // NaN 与自己都不相等，所以输出 false
     println(nan == nan)
 }

```

## 字符型
通常用于表示单个字符，字符型必须用‘引起来。Kotlin使用了16位Unicode字符集作为编码格式
字符型的三种格式
* 直接通过单个字符来指定字符型值，例如’A’、’9’和’0’等。
* 通过转义字符表示特殊字符型值，例如'\n'、'\t'等。
* 直接使用 Unicode 值来表示字符型值，格式是＇＼uXXXX’，其中 xxxx 代表 一个十六进制的整数(utf-16)。
常用转义字符
转义字符
说明
Unicode 表示方式
\b 退格符 \u0008
\n 换行符 \uOOOa
\r 回车符 \uOOOd
\t 制表符 \u0009
\" 双引号 \u0022
\' 单引号 \u0027
\\ 反斜线 \u005c
字符型值 也可以采用十六进制编码方式来表示，范围是＇\uOOOO＇~＇\uFFFF’， 一 共可以表示
65536 个字符，其中前 256 个（\uOOOO’~＇\uOOFF’）字符和 ASCII 码中的字符完全重合 。
```kotlin
 fun main() {
     val aChar = 'a'
     println(aChar)
 }
```

### 数值间的类型转换
Kotlin 与 Java 不同， Katlin 不支持取值范围 小的数据类型隐式转换为取值范围大的类型。
Kotlin 为所有数值类型都提供了如下方法进行转换。
* toByte （）：转换为 Byte 类型。
* toShort（）：转换为 Short 类型 。
* toInt（）：转换为 Int 类型。
* tolong （）：转换为 Long 类型 。
* toFloat（）：转换为 Float 类型 。
* toDouble （）： 转换为 Double 类型。
* toChar（）：转换为 Char 类型。
```kotlin
 fun main() {
     val a: Int = 42
     val b: Long = a.toLong()      // Int → Long
     val c: Double = a.toDouble()  // Int → Double
     val d: Byte = a.toByte()      // Int → Byte（可能会溢出）
     val e: Char = a.toChar()      // Int → Char（按 Unicode 编码转换）
     val f: Float = b.toFloat()    // Long → Float

     println("Int: $a")
     println("Int → Long: $b")
     println("Int → Double: $c")
     println("Int → Byte: $d")
     println("Int → Char: $e")
     println("Long → Float: $f")
 }
 /**
   * Int: 42
   * Int → Long: 42
   * Int → Double: 42.0
   * Int → Byte: 42
   * Int → Char: *
   * Long → Float: 42.0
   */
```
大范围转换为小范围时请注意取值范围

虽然 Kotlin 缺乏隐式转换，但 Kotlin 在表达式中可以自动转换
```kotlin
 fun main() {
    val bookPrice : Byte = 79
    val itemPrice : Short = 120
    //算术表达式中的 bookPrice、itemPrice 会自动提升为 Int 类型
    var total = bookPrice + itemPrice
    println("total的值为: $total")
    //可以看到 total 映射的 Java 类型为Int
    println("total 的类型为：${total.javaClass}")
    //由于一个是 Long，另一个是 Byte，Byte 会自动提升为 Long，相加的结果也是 Long
    val tot = bookPrice.toLong() + itemPrice.toByte()
    println("total 的值为：$tot")
    //可以看到 total 映射的 Java 类型为 long
    println("total 的类型为：$｛tot.javaClass｝")
 }
```
上面代码中的javaClass属性来自Any类(kt中所有类型的根父类)，
javaClass类似于getClass方法，可以用于获取指定变量对应的java类型

Kotlin 虽然不允许直接将 Char 型值当成整数值使用，也不允许将整数值直接当成 Char 型
值使用，但是还是可以使用toChar()方法将数值型变量或表达式转换为Char类型
```kotlin
 fun main() {
     val int = 97
     val char = (int+4).toChar() //char='e'
     println(int.toChar()) //a
     println(char) //e
 }
```
Char 型值虽然不能被当成整数进行算术运算，但 Kotlin 为 Char 类型提供了加、减
运算支持，其计算规则如下。
* Char 型值加、减一个整型值： Kotlin 会先将该 Char 型值对应的字符编码进行加、减
该整数，然后将计算结果转换为 Char 型值。
* 两个 Char 型值进行相减： Kotlin 将用两个 Char 型值对应的字符编码进行减法运算，
最后返回 Int 类型的值。
*注意：两个 Char 型值不能相加。*
*例子*
```kotlin
 fun main() {
     val c1 = 'i'
     val c2 = 'k'
     println(c1+4) // m
     println(c1-4) // e
     println(c1-c2) //-2
 }
```

### 浮点类型转换为整型
将 Double 类型或 Float 类型的值、变量或常量强制转换为整型时，浮点值的小数部分会被
截断，例如 4.75 将会变成 4, -2.9 将会被截断为－2 。

### 表达式类型的自动提升
当一个算术表达式中包含多个数值型的值时，整个算术表达式的数据类型将发生自动提升为表达式中范围最大的值 。
Kotlin 定义了与 Java 基本相似的自动提升规则。
Byte -> Short -> Int -> Long -> Float -> Double

如果两个整数进行整除，结果的小数点后会被截断，结果任是整型
```kotlin
 fun main() {
     val num = 2/3
     println(num) // 0
 }
```
隐式转换示例
```kotlin
 fun main() {
     val b = 60.toByte()
     val s = 80.toShort()
     val i = 100
     val l = 125.toLong()
     val f = 125.5.toFloat()
     val d = 256.6

     val res = b+s+i+l+f+d
     println(res)
     println(res.javaClass)
 }//输出:
 /*47.1
   *double
   */
```
字符与字符串隐式转换
```kotlin
 println("hello"+'a'+7)
 println('a'+7+"hello")
```
代码解释
* 第一个打印(helloa7)：先进行"hello"+'a' 字符隐式转换为字符串拼接，拼接成"helloa"，
再进行"helloa"+7，数值类型隐式转换为字符串，然后拼接，结果为“helloa7”
* 第二个打印(hhello)：先进行'a'+7='h',随后进行'h'+“hello”，将字符转换为字符串然后拼接，结果为“hhello”

## Boolean类型
与Java相同，Boolean的值为true或false,并能用0或非0表示，
其他数据类型通过条件表达式可以转换为Boolean型，但不能强制转换